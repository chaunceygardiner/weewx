#!/usr/bin/env python
#
# Copyright 2014 Matthew Wall
# See the file LICENSE.txt for your rights.

"""Driver for CC3000 data logger

http://www.rainwise.com/products/attachments/6832/20110518125531.pdf

There are a few variants:

CC-3000_ - __
       |   |
       |   41 = 418 MHz
       |   42 = 433 MHz
       |   __ = 2.4 GHz (LR compatible)
       R = serial (RS232, RS485)
       _ = USB 2.0

The CC3000 communicates using FTDI USB serial bridge.  The CC3000R has both
RS-232 and RS-485 serial ports, only one of which may be used at a time.
A long range (LR) version transmits up to 2 km using 2.4GHz.

The RS232 communicates using 115200 N-8-1

The instrument cluster contains a DIP switch controls with value 0-3 and a
default of 0.  This setting prevents interference when there are multiple
weather stations within radio range.

The CC3000 includes a temperature sensor - that is the source of inTemp.  The
manual indicates that the CC3000 should run for 3 or 4 hours before applying
any calibration to offset the heat generated by CC3000 electronics.

The CC3000 uses 4 AA batteries to maintain its clock.  Use only rechargeable
NiMH batteries.

The logger contains 2MB of memory, with a capacity of 49834 records (over 11
months of data at a 10 minute logging interval).  The exact capacity depends
on the sensors; the basic sensor record is 42 bytes.

The logger does not delete old records when it fills up; once the logger is
full, new data are lost.  So the driver must periodically clear the logger
memory.

This driver does not support hardware record_generation.  It does support
catchup on startup.

If you request many history records then interrupt the receive, the logger will
continue to send history records until it sends all that were requested.  As a
result, any queries made while the logger is still sending will fail.

The rainwise rain bucket measures 0.01 inches per tip.  The logger firmware
automatically converts the bucket tip count to the measure of rain in ENGLISH
or METRIC units.

The historical records (DOWNLOAD), as well as current readings (NOW) track
the amount of rain since midnight; i.e., DOWNLOAD records rain value resets to 0
at midnight and NOW records do the same.

The RAIN=? returns a rain counter that only resets with the RAIN=RESET command.
This counter isn't used by weewx.  Also, RAIN=RESET doesn't just reset this
counter, it also resets the daily rain count.

Logger uses the following units:
               ENGLISH  METRIC
  wind         mph      m/s
  rain         inch     mm
  pressure     inHg     mbar
  temperature  F        C

FIXME: Reading the history logger at full speed seems to cause problems on some
       systems, specifically with the system log and the USB.  It seems like we
       have no data loss, but logging of the history reads is lossy, especially
       with debug enabled.
       UPDATE: This has never been observed with v1.3 Build 022 Dec 02 2016?
               running on two NUC7i5 computers.

This driver was tested with:
  Rainwise CC-3000 Version: 1.3 Build 022 Dec 02 2016

Earlier versions of this driver were tested with:
  Rainwise CC-3000 Version: 1.3 Build 006 Sep 04 2013
  Rainwise CC-3000 Version: 1.3 Build 016 Aug 21 2014
"""

# FIXME: Come up with a way to deal with firmware inconsistencies.  if we do
#        a strict protocol where we wait for an OK response, but one version of
#        the firmware responds whereas another version does not, this leads to
#        comm problems.  specializing the code to handle quirks of each
#        firmware version is not desirable.
#        UPDATE: As of 0.30, the driver does a flush of the serial buffer before
#        doing any command.  The problem detailed above (OK not being returned)
#        was probably because the timeout was too short for the MEM=CLEAR
#        command.  That command gets a longer timeout in version 0.30.

# FIXME: Figure out why system log messages are lost.  When reading from the logger
#        there are many messages to the log that just do not show up, or msgs
#        that appear in one run but not in a second, identical run.  I suspect
#        that system log cannot handle the load?  or its buffer is not big enough?
#        Update:
#        With debug=0, this has never been observed in v1.3 Build 22 Dec 02 2016.
#        With debug=1, tailing the log looks like everything is running, but no
#        attempt was made to compuare log data between runs.  Observations on
#        NUC7i5 running Debian Buster.

from __future__ import with_statement
from __future__ import absolute_import
from __future__ import print_function
import datetime
import logging
import math
import serial
import string
import sys
import time

from six import byte2int
from six import PY2
from six.moves import input

import weeutil.weeutil
import weewx.drivers
import weewx.wxformulas
from weeutil.weeutil import to_int
from weewx.crc16 import crc16

log = logging.getLogger(__name__)

DRIVER_NAME = 'CC3000'
DRIVER_VERSION = '0.30'

def loader(config_dict, engine):
    return CC3000Driver(**config_dict[DRIVER_NAME])

def configurator_loader(config_dict):
    return CC3000Configurator()

def confeditor_loader():
    return CC3000ConfEditor()

DEBUG_SERIAL = 0
DEBUG_CHECKSUM = 0
DEBUG_OPENCLOSE = 0


class ChecksumError(weewx.WeeWxIOError):
    def __init__(self, msg):
        weewx.WeeWxIOError.__init__(self, msg)

class ChecksumMismatch(ChecksumError):
    def __init__(self, a, b, buf=None):
        msg = "Checksum mismatch: 0x%04x != 0x%04x" % (a, b)
        if buf is not None:
            msg = "%s (%s)" % (msg, buf)
        ChecksumError.__init__(self, msg)

class BadCRC(ChecksumError):
    def __init__(self, a, b, buf=None):
        msg = "Bad CRC: 0x%04x != '%s'" % (a, b)
        if buf is not None:
            msg = "%s (%s)" % (msg, buf)
        ChecksumError.__init__(self, msg)


class CC3000Configurator(weewx.drivers.AbstractConfigurator):
    def add_options(self, parser):
        super(CC3000Configurator, self).add_options(parser)
        parser.add_option("--info", dest="info", action="store_true",
                          help="display weather station configuration")
        parser.add_option("--current", dest="current", action="store_true",
                          help="display current weather readings")
        parser.add_option("--history", dest="nrecords", type=int, metavar="N",
                          help="display N records (0 for all records)")
        parser.add_option("--history-since", dest="nminutes", metavar="N",
                          type=int, help="display records since N minutes ago")
        parser.add_option("--clear-memory", dest="clear", action="store_true",
                          help="clear station memory")
        parser.add_option("--get-rain", dest="getrain", action="store_true",
                          help="get the rain counter")
        parser.add_option("--reset-rain", dest="resetrain", action="store_true",
                          help="reset the rain counter")
        parser.add_option("--get-max", dest="getmax", action="store_true",
                          help="get the max values observed")
        parser.add_option("--reset-max", dest="resetmax", action="store_true",
                          help="reset the max counters")
        parser.add_option("--get-min", dest="getmin", action="store_true",
                          help="get the min values observed")
        parser.add_option("--reset-min", dest="resetmin", action="store_true",
                          help="reset the min counters")
        parser.add_option("--get-clock", dest="getclock", action="store_true",
                          help="display station clock")
        parser.add_option("--set-clock", dest="setclock", action="store_true",
                          help="set station clock to computer time")
        parser.add_option("--get-interval", dest="getint", action="store_true",
                          help="display logger archive interval, in seconds")
        parser.add_option("--set-interval", dest="interval", metavar="N",
                          type=int,
                          help="set logging interval to N seconds")
        parser.add_option("--get-units", dest="getunits", action="store_true",
                          help="show units of logger")
        parser.add_option("--set-units", dest="units", metavar="UNITS",
                          help="set units to METRIC or ENGLISH")
        parser.add_option('--get-dst', dest='getdst', action='store_true',
                          help='display daylight savings settings')
        parser.add_option('--set-dst', dest='setdst',
                          metavar='mm/dd HH:MM,mm/dd HH:MM,[MM]M',
                          help='set daylight savings start, end, and amount')
        parser.add_option("--get-channel", dest="getch", action="store_true",
                          help="display the station channel")
        parser.add_option("--set-channel", dest="ch", metavar="CHANNEL",
                          type=int,
                          help="set the station channel")

    def do_options(self, options, parser, config_dict, prompt):
        self.driver = CC3000Driver(**config_dict[DRIVER_NAME])
        if options.current:
            print(self.driver.get_current())
        elif options.nrecords is not None:
            for r in self.driver.station.gen_records(options.nrecords):
                print(r)
        elif options.nminutes is not None:
            since_ts = time.mktime((datetime.datetime.now()-datetime.timedelta(
                                    minutes=nminutes)).timetuple())
            for r in self.driver.gen_records_since_ts(since_ts):
                print(r)
        elif options.clear:
            self.clear_memory(prompt)
        elif options.getrain:
            print(self.driver.station.get_rain())
        elif options.resetrain:
            self.reset_rain(prompt)
        elif options.getmax:
            print(self.driver.station.get_max())
        elif options.resetmax:
            self.reset_max(prompt)
        elif options.getmin:
            print(self.driver.station.get_min())
        elif options.resetmin:
            self.reset_min(prompt)
        elif options.getclock:
            print(self.driver.station.get_time())
        elif options.setclock:
            self.set_clock(prompt)
        elif options.getdst:
            print(self.driver.station.get_dst())
        elif options.setdst:
            self.set_dst(options.setdst, prompt)
        elif options.getint:
            print(self.driver.station.get_interval() * 60)
        elif options.interval is not None:
            self.set_interval(options.interval / 60, prompt)
        elif options.getunits:
            print(self.driver.station.get_units())
        elif options.units is not None:
            self.set_units(options.units, prompt)
        elif options.getch:
            print(self.driver.station.get_channel())
        elif options.ch is not None:
            self.set_channel(options.ch, prompt)
        else:
            print("Firmware:", self.driver.station.get_version())
            print("Time:", self.driver.station.get_time())
            print("DST:", self.driver.station.get_dst())
            print("Units:", self.driver.station.get_units())
            print("Memory:", self.driver.station.get_memory_status())
            print("Interval:", self.driver.station.get_interval() * 60)
            print("Channel:", self.driver.station.get_channel())
            print("Charger:", self.driver.station.get_charger())
            print("Baro:", self.driver.station.get_baro())
            print("Rain:", self.driver.station.get_rain())
            print("MAX:", self.driver.station.get_max())
            print("MIN:", self.driver.station.get_min())
        self.driver.closePort()

    def clear_memory(self, prompt):
        ans = None
        while ans not in ['y', 'n']:
            print(self.driver.station.get_memory_status())
            if prompt:
                ans = input("Clear console memory (y/n)? ")
            else:
                print('Clearing console memory')
                ans = 'y'
            if ans == 'y':
                self.driver.station.clear_memory()
                print(self.driver.station.get_memory_status())
            elif ans == 'n':
                print("Clear memory cancelled.")

    def reset_rain(self, prompt):
        ans = None
        while ans not in ['y', 'n']:
            print(self.driver.station.get_rain())
            if prompt:
                ans = input("Reset rain counter (y/n)? ")
            else:
                print('Resetting rain counter')
                ans = 'y'
            if ans == 'y':
                self.driver.station.reset_rain()
                print(self.driver.station.get_rain())
            elif ans == 'n':
                print("Reset rain cancelled.")

    def reset_max(self, prompt):
        ans = None
        while ans not in ['y', 'n']:
            print(self.driver.station.get_max())
            if prompt:
                ans = input("Reset max counters (y/n)? ")
            else:
                print('Resetting max counters')
                ans = 'y'
            if ans == 'y':
                self.driver.station.reset_max()
                print(self.driver.station.get_max())
            elif ans == 'n':
                print("Reset max cancelled.")

    def reset_min(self, prompt):
        ans = None
        while ans not in ['y', 'n']:
            print(self.driver.station.get_min())
            if prompt:
                ans = input("Reset min counters (y/n)? ")
            else:
                print('Resetting min counters')
                ans = 'y'
            if ans == 'y':
                self.driver.station.reset_min()
                print(self.driver.station.get_min())
            elif ans == 'n':
                print("Reset min cancelled.")

    def set_interval(self, interval, prompt):
        if interval < 0 or 60 < interval:
            raise ValueError("Logger interval must be 0-60 minutes")
        ans = None
        while ans not in ['y', 'n']:
            print("Interval is", self.driver.station.get_interval(), " minutes.")
            if prompt:
                ans = input("Set interval to %d minutes (y/n)? " % interval)
            else:
                print("Setting interval to %d minutes" % interval)
                ans = 'y'
            if ans == 'y':
                self.driver.station.set_interval(interval)
                print("Interval is now", self.driver.station.get_interval())
            elif ans == 'n':
                print("Set interval cancelled.")

    def set_clock(self, prompt):
        ans = None
        while ans not in ['y', 'n']:
            print("Station clock is", self.driver.station.get_time())
            now = datetime.datetime.now()
            if prompt:
                ans = input("Set station clock to %s (y/n)? " % now)
            else:
                print("Setting station clock to %s" % now)
                ans = 'y'
            if ans == 'y':
                self.driver.station.set_time()
                print("Station clock is now", self.driver.station.get_time())
            elif ans == 'n':
                print("Set clock cancelled.")

    def set_units(self, units, prompt):
        if units.lower() not in ['metric', 'english']:
            raise ValueError("Units must be METRIC or ENGLISH")
        ans = None
        while ans not in ['y', 'n']:
            print("Station units is", self.driver.station.get_units())
            if prompt:
                ans = input("Set station units to %s (y/n)? " % units)
            else:
                print("Setting station units to %s" % units)
                ans = 'y'
            if ans == 'y':
                self.driver.station.set_units(units)
                print("Station units is now", self.driver.station.get_units())
            elif ans == 'n':
                print("Set units cancelled.")

    def set_dst(self, dst, prompt):
        if dst != '0' and len(dst.split(',')) != 3:
            raise ValueError("DST must be 0 (disabled) or start, stop, amount "
                             "with the format mm/dd HH:MM, mm/dd HH:MM, [MM]M")
        ans = None
        while ans not in ['y', 'n']:
            print("Station DST is", self.driver.station.get_dst())
            if prompt:
                ans = input("Set DST to %s (y/n)? " % dst)
            else:
                print("Setting station DST to %s" % dst)
                ans = 'y'
            if ans == 'y':
                self.driver.station.set_dst(dst)
                print("Station DST is now", self.driver.station.get_dst())
            elif ans == 'n':
                print("Set DST cancelled.")

    def set_channel(self, ch, prompt):
        if ch not in [0, 1, 2, 3]:
            raise ValueError("Channel must be one of 0, 1, 2, or 3")
        ans = None
        while ans not in ['y', 'n']:
            print("Station channel is", self.driver.station.get_channel())
            if prompt:
                ans = input("Set channel to %s (y/n)? " % ch)
            else:
                print("Setting station channel to %s" % ch)
                ans = 'y'
            if ans == 'y':
                self.driver.station.set_channel(ch)
                print("Station channel is now", self.driver.station.get_channel())
            elif ans == 'n':
                print("Set channel cancelled.")


class CC3000Driver(weewx.drivers.AbstractDevice):
    """weewx driver that communicates with a RainWise CC3000 data logger."""

    # map rainwise names to database schema names
    DEFAULT_SENSOR_MAP = {
        'dateTime': 'TIMESTAMP',
        'outTemp': 'TEMP OUT',
        'outHumidity': 'HUMIDITY',
        'windDir': 'WIND DIRECTION',
        'windSpeed': 'WIND SPEED',
        'windGust': 'WIND GUST',
        'pressure': 'PRESSURE',
        'inTemp': 'TEMP IN',
        'extraTemp1': 'TEMP 1',
        'extraTemp2': 'TEMP 2',
        'day_rain_total': 'RAIN',
        'supplyVoltage': 'STATION BATTERY',
        'consBatteryVoltage': 'BATTERY BACKUP',
        'radiation': 'SOLAR RADIATION',
        'UV': 'UV INDEX',
    }

    def __init__(self, **stn_dict):
        log.info('Driver version is %s' % DRIVER_VERSION)

        global DEBUG_SERIAL
        DEBUG_SERIAL = int(stn_dict.get('debug_serial', 0))
        global DEBUG_CHECKSUM
        DEBUG_CHECKSUM = int(stn_dict.get('debug_checksum', 0))
        global DEBUG_OPENCLOSE
        DEBUG_OPENCLOSE = int(stn_dict.get('debug_openclose', 0))

        self.max_tries = int(stn_dict.get('max_tries', 5))
        self.model = stn_dict.get('model', 'CC3000')
        port = stn_dict.get('port', CC3000.DEFAULT_PORT)
        log.info('Using serial port %s' % port)
        self.polling_interval = float(stn_dict.get('polling_interval', 1))
        log.info('Polling interval is %s seconds' % self.polling_interval)
        self.use_station_time = weeutil.weeutil.to_bool(
            stn_dict.get('use_station_time', True))
        log.info('Using %s time for loop packets' %
               ('station' if self.use_station_time else 'computer'))
        # start with the default sensormap, then augment with user-specified
        self.sensor_map = dict(self.DEFAULT_SENSOR_MAP)
        if 'sensor_map' in stn_dict:
            self.sensor_map.update(stn_dict['sensor_map'])
        log.info('Sensor map is %s' % self.sensor_map)

        # periodically check the logger memory, then clear it if necessary.
        # these track the last time a check was made, and how often to make
        # the checks.  threshold of None indicates do not clear logger.
        self.logger_threshold = to_int(
            stn_dict.get('logger_threshold', None))
        self.last_mem_check = 0
        self.mem_interval = 7 * 24 * 3600
        if self.logger_threshold is not None:
            log.info('Clear logger at %s records' % self.logger_threshold)

        # track the last rain counter value so we can determine deltas
        self.last_rain = None

        self.station = CC3000(port)
        self.station.open()

        # report the station configuration
        settings = self._init_station_with_retries(self.station, self.max_tries)
        log.info('Firmware: %s' % settings['firmware'])
        self.arcint = settings['arcint']
        log.info('Archive interval: %s' % self.arcint)
        self.header = settings['header']
        log.info('Header: %s' % self.header)
        self.units = weewx.METRICWX if settings['units'] == 'METRIC' else weewx.US
        log.info('Units: %s' % settings['units'])
        log.info('Channel: %s' % settings['channel'])
        log.info('Charger status: %s' % settings['charger'])
        log.info('Memory: %s' % self.station.get_memory_status())

    def genLoopPackets(self):
        cmd_mode = True
        if self.polling_interval == 0:
            self.station.set_auto()
            cmd_mode = False

        logged_nodata = False
        ntries = 0
        while ntries < self.max_tries:
            ntries += 1
            try:
                values = self.station.get_current_data(cmd_mode)
                now = int(time.time())
                ntries = 0
                log.debug("Values: %s" % values)
                if values:
                    logged_nodata = False
                    packet = self._parse_current(
                        values, self.header, self.sensor_map)
                    log.debug("Parsed: %s" % packet)
                    if packet and 'dateTime' in packet:
                        if not self.use_station_time:
                            packet['dateTime'] = int(time.time() + 0.5)
                        packet['usUnits'] = self.units
                        if 'day_rain_total' in packet:
                            packet['rain'] = self._rain_total_to_delta(
                                packet['day_rain_total'], self.last_rain)
                            self.last_rain = packet['day_rain_total']
                        else:
                            log.debug("No rain in packet: %s" % packet)
                        log.debug("Packet: %s" % packet)
                        yield packet
                else:
                    if not logged_nodata:
                        log.info("No data from sensors")
                        logged_nodata = True

                # periodically check memory, clear if necessary
                if time.time() - self.last_mem_check > self.mem_interval:
                    nrec = self.station.get_history_usage()
                    self.last_mem_check = time.time()
                    if nrec is None:
                        log.info("Memory check: Cannot determine memory usage")
                    else:
                        log.info("Logger is at %d records, "
                               "logger clearing threshold is %d" %
                               (nrec, self.logger_threshold))
                        if self.logger_threshold is not None and nrec >= self.logger_threshold:
                            log.info("Clearing all records from logger")
                            self.station.clear_memory()

                if self.polling_interval:
                    time.sleep(self.polling_interval)
            except (serial.serialutil.SerialException, weewx.WeeWxIOError) as e:
                log.error("Failed attempt %d of %d to get data: %s" %
                       (ntries, self.max_tries, e))
        else:
            msg = "Max retries (%d) exceeded" % self.max_tries
            log.error(msg)
            raise weewx.RetriesExceeded(msg)

    def genStartupRecords(self, since_ts):
        """Return archive records from the data logger.  Download all records
        then return the subset since the indicated timestamp.

        Assumptions:
         - the units are consistent for the entire history.
         - the archive interval is constant for entire history.
         - the HDR for archive records is the same as current HDR
        """
        log.debug("GenStartupRecords: since_ts=%s" % since_ts)
        log.info('Downloading new records (if any).')
        last_rain = None
        new_records = 0
        for pkt in self.gen_records_since_ts(since_ts):
            log.debug("Packet: %s" % pkt)
            pkt['usUnits'] = self.units
            pkt['interval'] = self.arcint
            if 'day_rain_total' in pkt:
                pkt['rain'] = self._rain_total_to_delta(
                    pkt['day_rain_total'], last_rain)
                last_rain = pkt['day_rain_total']
            else:
                log.debug("No rain in record: %s" % r)
            log.debug("Packet: %s" % pkt)
            new_records += 1
            yield pkt
        log.info('Downloaded %d new records.' % new_records)

    def gen_records_since_ts(self, since_ts):
        return self.station.gen_records_since_ts(self.header, self.sensor_map, since_ts)

    @property
    def hardware_name(self):
        return self.model

    @property
    def archive_interval(self):
        return self.arcint

    def getTime(self):
        try:
            v = self.station.get_time()
            return _to_ts(v)
        except ValueError as e:
            log.error("getTime failed: %s" % e)
        return 0

    def setTime(self):
        self.station.set_time()

    @staticmethod
    def _init_station_with_retries(station, max_tries):
        for cnt in range(max_tries):
            try:
                return CC3000Driver._init_station(station)
            except (serial.serialutil.SerialException, weewx.WeeWxIOError) as e:
                log.error("Failed attempt %d of %d to initialize station: %s" %
                       (cnt + 1, max_tries, e))
        else:
            raise weewx.RetriesExceeded("Max retries (%d) exceeded while initializing station" % max_tries)

    @staticmethod
    def _init_station(station):
        station.flush()
        station.wakeup()
        station.set_echo()
        settings = dict()
        settings['firmware'] = station.get_version()
        settings['arcint'] = station.get_interval() * 60 # arcint is in seconds
        settings['header'] = CC3000Driver._parse_header(station.get_header())
        settings['units'] = station.get_units()
        settings['channel'] = station.get_channel()
        settings['charger'] = station.get_charger()
        return settings

    @staticmethod
    def _rain_total_to_delta(rain_total, last_rain):
        # calculate the rain delta between the current and previous rain totals.
        return weewx.wxformulas.calculate_rain(rain_total, last_rain)

    @staticmethod
    def _parse_current(values, header, sensor_map):
        return CC3000Driver._parse_values(values, header, sensor_map,
                                          "%Y/%m/%d %H:%M:%S")

    @staticmethod
    def _parse_values(values, header, sensor_map, fmt):
        """parse the values and map them into the schema names.  if there is
        a failure for any one value, then the entire record fails."""
        pkt = dict()
        if len(values) != len(header) + 1:
            log.info("Values/header mismatch: %s %s" % (values, header))
            return pkt
        for i, v in enumerate(values):
            if i >= len(header):
                continue
            label = None
            for m in sensor_map:
                if sensor_map[m] == header[i]:
                    label = m
            if label is None:
                continue
            try:
                if header[i] == 'TIMESTAMP':
                    pkt[label] = _to_ts(v, fmt)
                else:
                    pkt[label] = float(v)
            except ValueError as e:
                log.error("Parse failed for '%s' '%s': %s (idx=%s values=%s)" %
                       (header[i], v, e, i, values))
                return dict()
        return pkt

    @staticmethod
    def _parse_header(header):
        h = []
        for v in header:
            if v == 'HDR' or v[0:1] == '!':
                continue
            h.append(v.replace('"', ''))
        return h

    def get_current(self):
        data = self.station.get_current_data()
        return self._parse_current(data, self.header, self.sensor_map)

def _to_ts(tstr, fmt="%Y/%m/%d %H:%M:%S"):
    return time.mktime(time.strptime(tstr, fmt))

def _format_bytes(buf):
    # byte2int returns a str in Python3.  As such, the %0.2X is not happy
    # about it.  That's not what six.byte2int doc says.
    if PY2:
        return ' '.join(['%0.2X' % byte2int(c) for c in buf])

def _check_crc(buf):
    idx = buf.find(b'!')
    if idx < 0:
        return
    a = 0
    b = 0
    cs = b''
    try:
        cs = buf[idx+1:idx+5]
        if DEBUG_CHECKSUM:
            log.debug("Found checksum at %d: %s" % (idx, cs))
        a = crc16(buf[0:idx]) # calculate checksum
        if DEBUG_CHECKSUM:
            log.debug("Calculated checksum %x" % a)
        b = int(cs, 16) # checksum provided in data
        if a != b:
            raise ChecksumMismatch(a, b, buf)
    except ValueError as e:
        raise BadCRC(a, cs, buf)

class CC3000(object):
    DEFAULT_PORT = '/dev/ttyUSB0'

    def __init__(self, port):
        self.port = port
        self.baudrate = 115200
        self.timeout = 1 # seconds for everyting except MEM=CLEAR
        # MEM=CLEAR of even two records needs a timeout of 13 or more.  20 is probably safe.
        #           flush    cmd      echo      value
        #           0.000022 0.000037 12.819934 0.000084
        #           0.000018 0.000036 12.852024 0.000088
        self.mem_clear_timeout = 20 # reopen w/ bigger  timeout for MEM=CLEAR
        self.serial_port = None

    def __enter__(self):
        self.open()
        return self

    def __exit__(self, _, value, traceback):
        self.close()

    def open(self, timeoutOverride=None):
        if DEBUG_OPENCLOSE:
            log.debug("Open serial port %s" % self.port)
        to = timeoutOverride if timeoutOverride is not None else self.timeout
        self.serial_port = serial.Serial(self.port, self.baudrate,
                                         timeout=to)

    def close(self):
        if self.serial_port is not None:
            if DEBUG_OPENCLOSE:
                log.debug("Close serial port %s" % self.port)
            self.serial_port.close()
            self.serial_port = None

    def write(self, data):
        if not PY2:
            # Encode could perhaps fail on bad user input (DST?).
            # If so, this will be handled later when it is observed that the
            # command does not do what is expected.
            data = data.encode('ascii', 'ignore')
        if DEBUG_SERIAL:
            log.debug("Write: '%s'" % data)
        n = self.serial_port.write(data)
        if n is not None and n != len(data):
            raise weewx.WeeWxIOError("Write expected %d chars, sent %d" %
                                     (len(data), n))

    def read(self):
        """The station sends CR NL before and after any response.  Some
        responses have a 4-byte CRC checksum at the end, indicated with an
        exclamation.  Not every response has a checksum.
        """
        data = self.serial_port.readline()
        if DEBUG_SERIAL:
            log.debug("Read: '%s' (%s)" % (data, _format_bytes(data)))
        data = data.strip()
        _check_crc(data)
        if not PY2:
            # CRC passed, so this is unlikely.
            # Ignore as irregular data will be handled later.
            data = data.decode('ascii', 'ignore')
        return data

    def flush(self):
        self.flush_input()
        self.flush_output()

    def flush_input(self):
        log.debug("Flush input buffer")
        self.serial_port.flushInput()

    def flush_output(self):
        log.debug("Flush output buffer")
        self.serial_port.flushOutput()

    def queued_bytes(self):
        return self.serial_port.inWaiting()

    def send_cmd(self, cmd):
        """Any command must be terminated with a CR"""
        self.write("%s\r" % cmd)

    def command(self, cmd):
        # Sample timings for first fifteen NOW commands after startup.
        #   Flush     CMD     ECHO     VALUE
        # -------- -------- -------- --------
        # 0.000021 0.000054 0.041557 0.001364
        # 0.000063 0.000109 0.040432 0.001666
        # 0.000120 0.000123 0.024272 0.016871
        # 0.000120 0.000127 0.025148 0.016657
        # 0.000119 0.000126 0.024966 0.016665
        # 0.000130 0.000142 0.041037 0.001791
        # 0.000120 0.000126 0.023533 0.017023
        # 0.000120 0.000137 0.024336 0.016747
        # 0.000117 0.000133 0.026254 0.016684
        # 0.000120 0.000140 0.025014 0.016739
        # 0.000121 0.000134 0.024801 0.016779
        # 0.000120 0.000141 0.024635 0.016906
        # 0.000118 0.000129 0.024354 0.016894
        # 0.000120 0.000133 0.024214 0.016861
        # 0.000118 0.000122 0.024599 0.016865

        # MEM=CLEAR needs a longer timeout.  >12s to clear a small number of records has been observed.
        # It also appears to be highly variable.  The two examples below are from two different CC3000s.
        #
        # In this example, clearing at 11,595 records took > 6s.
        # Aug 18 06:46:21 charlemagne weewx[684]: cc3000: logger is at 11595 records, logger clearing threshold is 10000
        # Aug 18 06:46:21 charlemagne weewx[684]: cc3000: clearing all records from logger
        # Aug 18 06:46:21 charlemagne weewx[684]: cc3000: MEM=CLEAR: The resetting of timeout to 20 took 0.000779 seconds.
        # Aug 18 06:46:28 charlemagne weewx[684]: cc3000: MEM=CLEAR: times: 0.000016 0.000118 6.281638 0.000076
        # Aug 18 06:46:28 charlemagne weewx[684]: cc3000: MEM=CLEAR: The resetting of timeout to 1 took 0.001444 seconds.
        # 
        # In this example, clearing at 11,475 records took > 12s.
        # Aug 18 07:17:14 ella weewx[615]: cc3000: logger is at 11475 records, logger clearing threshold is 10000
        # Aug 18 07:17:14 ella weewx[615]: cc3000: clearing all records from logger
        # Aug 18 07:17:14 ella weewx[615]: cc3000: MEM=CLEAR: The resetting of timeout to 20 took 0.001586 seconds.
        # Aug 18 07:17:27 ella weewx[615]: cc3000: MEM=CLEAR: times: 0.000020 0.000058 12.459346 0.000092
        # Aug 18 07:17:27 ella weewx[615]: cc3000: MEM=CLEAR: The resetting of timeout to 1 took 0.001755 seconds.
        #
        # Here, clearing 90 records took very close to 13 seconds.
        # Aug 18 14:46:00 ella weewx[24602]: cc3000: logger is at 91 records, logger clearing threshold is 90
        # Aug 18 14:46:00 ella weewx[24602]: cc3000: clearing all records from logger
        # Aug 18 14:46:00 ella weewx[24602]: cc3000: MEM=CLEAR: The resetting of timeout to 20 took 0.000821 seconds.
        # Aug 18 14:46:13 ella weewx[24602]: cc3000: MEM=CLEAR: times: 0.000037 0.000061 12.970494 0.000084
        # Aug 18 14:46:13 ella weewx[24602]: cc3000: MEM=CLEAR: The resetting of timeout to 1 took 0.001416 seconds.

        reset_timeout = False

        # MEM=CLEAR needs a much larger timeout value.  Reopen with that larger timeout and reset below.
        #
        # Closing and reopening with a different timeout is quick:
        #     Aug 18 07:17:14 ella weewx[615]: cc3000: MEM=CLEAR: The resetting of timeout to 20 took 0.001586 seconds.
        #     Aug 18 07:17:27 ella weewx[615]: cc3000: MEM=CLEAR: The resetting of timeout to 1 took 0.001755 seconds.
        if cmd == 'MEM=CLEAR':
            reset_timeout = True # Reopen with default timeout in finally.
            t1 = time.time()
            self.close()
            self.open(self.mem_clear_timeout)
            t2 = time.time()
            close_open_time = t2 - t1
            log.info("%s: The resetting of timeout to %d took %f seconds." % (cmd, self.mem_clear_timeout, close_open_time))

        try:
            # All commands will be retried if they timeout.
            t1 = time.time()
            self.flush()          # flush - TBD if this provides any benefit
            t2 = time.time()
            flush_time = t2 - t1
            self.send_cmd(cmd)    # send cmd
            t3 = time.time()
            cmd_time = t3 - t2
            data = self.read()    # read the cmd echo
            t4 = time.time()
            echo_time = t4 - t3

            retrying = False      # set to true below if retrying, so we can report on retry success

            # if a command timed out reading back the echo of the command, retry.  In practice, the retry always works.
            if (cmd != 'MEM=CLEAR' and echo_time >= self.timeout) or (cmd == 'MEM=CLEAR' and echo_time >= self.mem_clear_timeout):
                log.info("%s: times: %f %f %f -retrying-" % (cmd, flush_time, cmd_time, echo_time))
                # Reading the echo timed out!  No need to read the values as it will also time out.
                log.info("%s: Reading cmd echo timed out (%f seconds), retrying." % (cmd, echo_time))
                # The command will be retried.  Retrying setting the time must be special cased as
                # now more than one second has passed.  As such, redo the command with the current time.
                if cmd.startswith("TIME=") and cmd != "TIME=?":
                    cmd = self._compose_set_time_command()
                t1 = time.time()
                self.flush()          # flush
                t2 = time.time()
                flush_time = t2 - t1
                self.send_cmd(cmd)    # send cmd
                t3 = time.time()
                cmd_time =  t3 - t2
                data = self.read()    # read cmd echo
                t4 = time.time()
                echo_time = t4 - t3
                if data != cmd:
                    if data == '':
                        log.info("%s: Accepting empty string as cmd echo." % cmd)
                    else:
                        raise weewx.WeeWxIOError(
                            "command: Command failed: cmd='%s' reply='%s'" % (cmd, data))
                retrying = True

            t5 = time.time()
            retval = self.read()
            t6 = time.time()
            value_time = t6 - t5
            if cmd == 'MEM=CLEAR':
                log.info("%s: times: %f %f %f %f" % (cmd, flush_time, cmd_time, echo_time, value_time))

            if retrying:
                if retval != '':
                    log.info("%s: Retry worked." % cmd)
                else:
                    log.info("%s: Retry failed." % cmd)
                log.info("%s: times: %f %f %f %f" % (cmd, flush_time, cmd_time, echo_time, value_time))

            return retval
        finally:
            if reset_timeout:
                t1 = time.time()
                self.close()
                self.open()
                reset_timeout = True
                t2 = time.time()
                close_open_time = t2 - t1
                log.info("%s: The resetting of timeout to %d took %f seconds." % (cmd, self.timeout, close_open_time))

    def get_version(self):
        log.debug("Get firmware version")
        return self.command("VERSION")

    # give the station some time to wake up.  when we first hit it with a
    # command, it often responds with an empty string.  then subsequent
    # commands get the proper response.  so for a first command, send something
    # innocuous and wait a bit.  hopefully subsequent commands will then work.
    # NOTE: This happens periodically and does not appear to be related to
    # "waking up".  Getter commands now retry, so removing the sleep.
    def wakeup(self):
        self.command('ECHO=?')

    def set_echo(self, cmd='ON'):
        log.debug("Set echo to %s" % cmd)
        data = self.command('ECHO=%s' % cmd)
        if data != 'OK':
            raise weewx.WeeWxIOError("Set ECHO failed: %s" % data)

    def get_header(self):
        log.debug("Get header")
        data = self.command("HEADER")
        cols = data.split(',')
        if cols[0] != 'HDR':
            raise weewx.WeeWxIOError("Expected HDR, got %s" % cols[0])
        return cols

    def set_auto(self):
        # auto does not echo the command
        self.send_cmd("AUTO")

    def get_current_data(self, send_now=True):
        data = ''
        if send_now:
            data = self.command("NOW")
        else:
            data = self.read()
        if data == 'NO DATA' or data == 'NO DATA RECEIVED':
            log.debug("No data from sensors")
            return []
        return data.split(',')

    def get_time(self):
        # unlike all of the other accessor methods, the TIME command returns
        # OK after it returns the requested parameter.  so we have to pop the
        # OK off the serial so it does not trip up other commands.
        log.debug("Get time")
        tstr = self.command("TIME=?")
        if tstr not in ['ERROR', 'OK']:
            data = self.read()
        if data != 'OK':
            raise weewx.WeeWxIOError("Failed to get time: %s, %s" % (tstr, data))
        return tstr

    @staticmethod
    def _compose_set_time_command():
        ts = time.time()
        tstr = time.strftime("%Y/%m/%d %H:%M:%S", time.localtime(ts))
        log.info("Set time to %s (%s)" % (tstr, ts))
        return "TIME=%s" % tstr

    def set_time(self):
        s = self._compose_set_time_command()
        data = self.command(s)
        if data != 'OK':
            raise weewx.WeeWxIOError("Failed to set time to %s: %s" %
                                     (s, data))

    def get_dst(self):
        log.debug("Get daylight saving")
        return self.command("DST=?")

    def set_dst(self, dst):
        log.debug("Set DST to %s" % dst)
        # Firmware 1.3 Build 022 Dec 02 2016 returns 3 lines (<input-dst>,'',OK)
        data = self.command("DST=%s" % dst) # echoed input dst
        if data != dst:
            raise weewx.WeeWxIOError("Failed to set DST to %s: %s" %
                                     (dst, data))
        data = self.read() # read ''
        if data not in ['ERROR', 'OK']:
            data = self.read() # read OK
        if data != 'OK':
            raise weewx.WeeWxIOError("Failed to set DST to %s: %s" %
                                     (dst, data))

    def get_units(self):
        log.debug("Get units")
        return self.command("UNITS=?")

    def set_units(self, units):
        log.debug("Set units to %s" % units)
        data = self.command("UNITS=%s" % units)
        if data != 'OK':
            raise weewx.WeeWxIOError("Failed to set units to %s: %s" %
                                     (units, data))

    def get_interval(self):
        log.debug("Get logging interval")
        return int(self.command("LOGINT=?"))

    def set_interval(self, interval=5):
        log.debug("Set logging interval to %d minutes" % interval)
        data = self.command("LOGINT=%d" % interval)
        if data != 'OK':
            raise weewx.WeeWxIOError("Failed to set logging interval: %s" %
                                     data)

    def get_channel(self):
        log.debug("Get channel")
        return self.command("STATION")

    def set_channel(self, channel):
        log.debug("Set channel to %d" % channel)
        if channel < 0 or 3 < channel:
            raise ValueError("Channel must be 0-3")
        data = self.command("STATION=%d" % channel)
        if data != 'OK':
            raise weewx.WeeWxIOError("Failed to set channel: %s" % data)

    def get_charger(self):
        log.debug("Get charger")
        return self.command("CHARGER")

    def get_baro(self):
        log.debug("Get baro")
        return self.command("BARO")

    def set_baro(self, offset):
        log.debug("Set barometer offset to %d" % offset)
        if offset != '0':
            parts = offset.split('.')
            if (len(parts) != 2 or
                (not (len(parts[0]) == 2 and len(parts[1]) == 2) and
                 not (len(parts[0]) == 3 and len(parts[1]) == 1))):
                raise ValueError("Offset must be 0, XX.XX (inHg), or XXXX.X (mbar)")
        data = self.command("BARO=%d" % offset)
        if data != 'OK':
            raise weewx.WeeWxIOError("Failed to set baro: %s" % data)

    def get_memory_status(self):
        # query for logger memory use.  output is something like this:
        # 6438 bytes, 111 records, 0%
        log.debug("Get memory status")
        return self.command("MEM=?")

    def get_max(self):
        log.debug("Get max values")
        # Return outside temperature, humidity, pressure, wind direction,
        # wind speed, rainfall (daily total), station voltage, inside
        # temperature.
        return self.command("MAX=?").split(',')

    def reset_max(self):
        log.debug("Reset max values")
        data = self.command("MAX=RESET")
        if data != 'OK':
            raise weewx.WeeWxIOError("Failed to reset max values: %s" % data)

    def get_min(self):
        log.debug("Get min values")
        # Return outside temperature, humidity, pressure, wind direction,
        # wind speed, rainfall (ignore), station voltage, inside temperature.
        return self.command("MIN=?").split(',')

    def reset_min(self):
        log.debug("Reset min values")
        data = self.command("MIN=RESET")
        if data != 'OK':
            raise weewx.WeeWxIOError("Failed to reset min values: %s" % data)

    def get_history_usage(self):
        # return the number of records in the logger
        # FIXME: some firmware returns NOW when you query MEM=?
        s = self.get_memory_status()
        if 'records' in s:
            return int(s.split(',')[1].split()[0])
        return None

    def clear_memory(self):
        log.debug("Clear memory")
        data = self.command("MEM=CLEAR")
        # It's a long wait for the OK.  With a greatly increased timeout
        # just for MEM=CLEAR, we should be able to read the OK.
        if data == 'OK':
            log.info("MEM=CLEAR succeeded.")
        else:
            raise weewx.WeeWxIOError("Failed to clear memory: %s" % data)

    def get_rain(self):
        log.debug("Get rain total")
        # Firmware 1.3 Build 022 Dec 02 2017 returns OK after the rain count
        # This is like TIME=?
        rstr = self.command("RAIN")
        if rstr not in ['ERROR', 'OK']:
            data = self.read()
        if data != 'OK':
            raise weewx.WeeWxIOError("Failed to get rain: %s" % data)
        return rstr

    def reset_rain(self):
        log.debug("Reset rain counter")
        data = self.command("RAIN=RESET")
        if data != 'OK':
            raise weewx.WeeWxIOError("Failed to reset rain: %s" % data)

    def gen_records_since_ts(self, header, sensor_map, since_ts):
        now_ts = time.mktime(datetime.datetime.now().timetuple())
        nseconds = now_ts - since_ts
        nminutes = math.ceil(nseconds / 60.0)
        num_records = math.ceil(nminutes / float(self.get_interval()))
        log.debug('gen_records_since_ts: Asking for %d records.' % num_records)
        for r in self.gen_records(nrec=num_records):
            pkt = CC3000Driver._parse_values(r[1:], header, sensor_map, "%Y/%m/%d %H:%M")
            if 'dateTime' in pkt and pkt['dateTime'] > since_ts:
                yield pkt

    def gen_records(self, nrec=0):
        """
        Generator function for getting nrec records from the device.  A value
        of 0 indicates all records.

        The CC3000 returns a header ('HDR,'), the archive records
        we are interested in ('REC,'), daily max and min records
        ('MAX,', 'MIN,') as well as messages for various events such as a
        reboot ('MSG,').

        Things get intereting when nrec is non-zero.

        DOWNLOAD=n returns the latest n records in memory.  The CC3000 does
        not distinguish between REC, MAX, MIN and MSG records in memory.
        As such, DOWNLOAD=5 does NOT mean fetch the latest 5 REC records.
        For example, if the latest 5 records include a MIN and a MAX record,
        only 3 REC records will be returned (along with the MIN and MAX
        records).

        Given that one can't ask pecisely ask for a given number of archive
        records, a heuristic is used and errs on the side of asking for
        too many records.

        The heurisitic for number of records to ask for is:
        the sum of:
            nrec
            7 * the number of days convered in the request (rounded up)
            Note: One can determine the number of days from the number of
                  records requested because the archive interval is known.

        Asking for an extra seven records per day allows for the one MIN and
        one MAX records generated per day, plus a buffer for up to five MSG
        records each day.  Unless one is rebooting the CC3000 all day, this
        will be plenty.  Typically, there will be zero MSG records.  Clearing
        memory and rebooting actions generate MSG records.  Both are uncommon.
        As a result, gen_records will overshoot the records asked for, but this
        is not a problem in practice.  Also, if a new archive record is written
        while this operation is taking place, it will be returned.  As such,
        the number wouldn't be precise anyway.  One could work around this by
        accumulating records before returning, and then returning an exact
        amount, but it simply isn't worth it.

        Examining the records in the CC3000 (808 records at the time of the
        examination) shows the following records found:
            HDR: 1   (the header record, per the spec)
            REC: 800 (the archive records -- ~2.8 days worth)
            MSG: 1 (A clear command that executed ~2.8 days ago:
                    MSG 2019/12/20 15:48 CLEAR ON COMMAND!749D)
            MIN: 3 (As expected for 3 days.)
            MAX: 3 (As expected for 3 days.)
        """

        totrec = self.get_history_usage()
        if totrec is None:
            raise weewx.WeeWxIOError("cannot determine logger memory status")
        log.debug("gen_records: Requested %d latest of %d records." % (nrec, totrec))

        if nrec == 0:
            num_to_ask = 0
        else:
            # Determine the number of records to ask for.
            # See heuristic above.
            num_mins_asked = nrec * self.get_interval()
            num_days_asked = math.ceil(num_mins_asked / (24.0*60))
            num_to_ask = nrec + 7 * num_days_asked

        # on some platforms the comms get wedged, so we need a way to reset
        need_cmd = True
        cmd_max = 5
        cmd_cnt = 0
        n = 0
        yielded = 0

        while True:
            if need_cmd:
                cmd_cnt += 1
                if cmd_cnt > cmd_max:
                    msg = "Download failed after %d attempts" % cmd_max
                    log.error(msg)
                    raise weewx.WeeWxIOError(msg)
                cmd = "DOWNLOAD"
                if num_to_ask != 0:
                    qty = num_to_ask - n
                    cmd = "DOWNLOAD=%d" % qty
                log.debug("%s (attempt %s of %s)" % (cmd, cmd_cnt, cmd_max))
                self.send_cmd(cmd)
                need_cmd = False
            try:
                data = self.read()
                if data == 'OK':
                    log.debug("Downloaded %d records, yielded %d" % (n, yielded))
                    break
                elif ',' in data:
                    values = data.split(',')
                    if values[0] == 'REC':
                        n += 1
                        cmd_cnt = 0
                        yielded += 1
                        yield values
                    elif (values[0] == 'HDR' or values[0] == 'MSG' or
                          values[0] == 'MIN' or values[0] == 'MAX' or
                          values[0].startswith('DOWNLOAD')):
                        # skip any non-REC responses
                        cmd_cnt = 0
                    elif values[0] == '':
                        # FIXME: observed 'input overrun' on rpi2 with debian 7
                        # so try sending another download command to unhang it.
                        log.error("Download hung, initiate another download")
                        need_cmd = True
                    else:
                        cmd_cnt = 0
                        log.error("Bad record %s '%s' (%s)" %
                               (n, values[0], data))
                elif 'DOWNLOAD' in data:
                    # some firmware echos the command, but not always
                    pass
                else:
                    log.error("Unexpected response to DOWNLOAD: '%s'" % data)
                    need_cmd = True
            except ChecksumError as e:
                log.error("Download failed for record %s: %s" % (n, e))


class CC3000ConfEditor(weewx.drivers.AbstractConfEditor):
    @property
    def default_stanza(self):
        return """
[CC3000]
    # This section is for RainWise MarkIII weather stations and CC3000 logger.

    # Serial port such as /dev/ttyS0, /dev/ttyUSB0, or /dev/cuaU0
    port = %s

    # The station model, e.g., CC3000 or CC3000R
    model = CC3000

    # The driver to use:
    driver = weewx.drivers.cc3000
""" % (CC3000.DEFAULT_PORT,)

    def prompt_for_settings(self):
        print("Specify the serial port on which the station is connected, for")
        print("example /dev/ttyUSB0 or /dev/ttyS0.")
        port = self._prompt('port', CC3000.DEFAULT_PORT)
        return {'port': port}


# define a main entry point for basic testing.  invoke from the weewx root dir:
#
# PYTHONPATH=bin python bin/weewx/drivers/cc3000.py

if __name__ == '__main__':
    import optparse

    import weewx
    import weeutil.logger

    usage = """%prog [options] [--help]"""

    parser = optparse.OptionParser(usage=usage)
    parser.add_option('--version', action='store_true',
                      help='display driver version')
    parser.add_option('--debug', action='store_true', default=False,
                      help='emit additional diagnostic information')
    parser.add_option('--test-crc', dest='testcrc', action='store_true',
                      help='test crc')
    parser.add_option('--port', metavar='PORT',
                      help='port to which the station is connected',
                      default=CC3000.DEFAULT_PORT)
    parser.add_option('--get-version', dest='getver', action='store_true',
                      help='display firmware version')
    parser.add_option('--get-status', dest='status', action='store_true',
                      help='display memory status')
    parser.add_option('--get-channel', dest='getch', action='store_true',
                      help='display station channel')
    parser.add_option('--set-channel', dest='setch', metavar='CHANNEL',
                      help='set station channel')
    parser.add_option('--get-battery', dest='getbat', action='store_true',
                      help='display battery status')
    parser.add_option('--get-current', dest='getcur', action='store_true',
                      help='display current data')
    parser.add_option('--get-memory', dest='getmem', action='store_true',
                      help='display memory status')
    parser.add_option('--get-records', dest='getrec', metavar='NUM_RECORDS',
                      help='display records from station memory')
    parser.add_option('--get-header', dest='gethead', action='store_true',
                      help='display data header')
    parser.add_option('--get-units', dest='getunits', action='store_true',
                      help='display units')
    parser.add_option('--set-units', dest='setunits', metavar='UNITS',
                      help='set units to ENGLISH or METRIC')
    parser.add_option('--get-time', dest='gettime', action='store_true',
                      help='display station time')
    parser.add_option('--set-time', dest='settime', action='store_true',
                      help='set station time to computer time')
    parser.add_option('--get-dst', dest='getdst', action='store_true',
                      help='display daylight savings settings')
    parser.add_option('--set-dst', dest='setdst',
                      metavar='mm/dd HH:MM,mm/dd HH:MM,[MM]M',
                      help='set daylight savings start, end, and amount')
    parser.add_option('--get-interval', dest='getint', action='store_true',
                      help='display logging interval, in seconds')
    parser.add_option('--set-interval', dest='setint', metavar='INTERVAL',
                      type=int, help='set logging interval, in seconds')
    parser.add_option('--clear-memory', dest='clear', action='store_true',
                      help='clear logger memory')
    parser.add_option('--get-rain', dest='getrain', action='store_true',
                      help='get rain counter')
    parser.add_option('--reset-rain', dest='resetrain', action='store_true',
                      help='reset rain counter')
    parser.add_option('--get-max', dest='getmax', action='store_true',
                      help='get max counter')
    parser.add_option('--reset-max', dest='resetmax', action='store_true',
                      help='reset max counters')
    parser.add_option('--get-min', dest='getmin', action='store_true',
                      help='get min counter')
    parser.add_option('--reset-min', dest='resetmin', action='store_true',
                      help='reset min counters')
    parser.add_option('--poll', metavar='POLL_INTERVAL', type=int,
                      help='poll interval in seconds')
    (options, args) = parser.parse_args()

    if options.version:
        print("%s driver version %s" % (DRIVER_NAME, DRIVER_VERSION))
        exit(0)

    if options.debug:
        DEBUG_SERIAL = 1
        DEBUG_CHECKSUM = 1
        DEBUG_OPENCLOSE = 1
        weewx.debug = 1

    weeutil.logger.setup('cc3000', {})

    if options.testcrc:
        _check_crc(b'OK')
        _check_crc(b'REC,2010/01/01 14:12, 64.5, 85,29.04,349,  2.4,  4.2,  0.00, 6.21, 0.25, 73.2,!B82C')
        _check_crc(b'MSG,2010/01/01 20:22,CHARGER ON,!4CED')
        exit(0)

    with CC3000(options.port) as s:
        s.flush()
        s.wakeup()
        s.set_echo()
        if options.getver:
            print(s.get_version())
        if options.status:
            print("Firmware:", s.get_version())
            print("Time:", s.get_time())
            print("DST:", s.get_dst())
            print("Units:", s.get_units())
            print("Memory:", s.get_memory_status())
            print("Interval:", s.get_interval() * 60)
            print("Channel:", s.get_channel())
            print("Charger:", s.get_charger())
            print("Baro:", s.get_baro())
            print("Rain:", s.get_rain())
            print("Max values:", s.get_max())
            print("Min values:", s.get_min())
        if options.getch:
            print(s.get_channel())
        if options.setch is not None:
            s.set_channel(int(options.setch))
        if options.getbat:
            print(s.get_charger())
        if options.getcur:
            print(s.get_current_data())
        if options.getmem:
            print(s.get_memory_status())
        if options.getrec is not None:
            i = 0
            for r in s.gen_records(int(options.getrec)):
                print(i, r)
                i += 1
        if options.gethead:
            print(s.get_header())
        if options.getunits:
            print(s.get_units())
        if options.setunits:
            s.set_units(options.setunits)
        if options.gettime:
            print(s.get_time())
        if options.settime:
            s.set_time()
        if options.getdst:
            print(s.get_dst())
        if options.setdst:
            s.set_dst(options.setdst)
        if options.getint:
            print(s.get_interval() * 60)
        if options.setint:
            s.set_interval(int(options.setint) / 60)
        if options.clear:
            s.clear_memory()
        if options.getrain:
            print(s.get_rain())
        if options.resetrain:
            print(s.reset_rain())
        if options.getmax:
            print(s.get_max())
        if options.resetmax:
            print(s.reset_max())
        if options.getmin:
            print(s.get_min())
        if options.resetmin:
            print(s.reset_min())
        if options.poll is not None:
            cmd_mode = True
            if options.poll == 0:
                cmd_mode = False
                s.set_auto()
            while True:
                print(s.get_current_data(cmd_mode))
                time.sleep(options.poll)
